- [Part2-4장. Part2-4장. 문자열](#part2-4장-part2-4장-문자열)
  - [1. 포인터와 문자열](#1-포인터와-문자열)
  - [2. 문자열 입력 함수](#2-문자열-입력-함수)
  - [3. 문자열 출력 함수](#3-문자열-출력-함수)
  - [4. 문자열 연산 함수](#4-문자열-연산-함수)

# Part2-4장. Part2-4장. 문자열

## 1. 포인터와 문자열

- 문자열

  - `“ ”` 내에 포함된 하나 이상의 문자 ex) `'A'` → 문자 / `"A"` → 문자열
  - 문자열의 끝에는 문자열의 끝을 알리는 종료 문자(`\0`) 삽입 ex) `"A"` == `"A\0"`
  - 문자열의 시작 주소를 알면 저장된 문자들에 접근 가능
  - 문자열은 문자열 상수와 문자열 변수로 구분
    ex) `"ABCD"` → 상수 (값 변경X)
    `char a[5]="ABCD";` == `char a[5]={'A', 'B', 'C', 'D', '\0'};`
    → 배열화해서 값 변경 가능
  - 문자열을 입력하고 출력할 때 서식문자 `%s`를 사용
    → 문자열의 시작 주소를 통해 출력 (시작주소부터 종료문자까지)
  - 메모리 공간에 연속으로 저장되어 있어 주소가 연속적 ex) `&a[0]`, `&a[1]`

  > 같은 문자열 반복 사용 시 헤더 파일에 정의하는 것이 효율적  
  >  ex) `#define HI "Hello C World!"`

- 널 문자

  - 종료문자 `‘\0’`
  - ASCII 코드 정수 0(10진수)
  - 문자열 끝에 저장

  > `char array1[ ]={'A', 'B', 'C', 'D', '\0'};` → 문자열 배열  
  >  `char array2[ ]={'A', 'B', 'C', 'D'};` → 문자 배열 (`%s`로 출력하면 이상한 값 나옴)

- 포인터: 문자열 시작 주소, 문자열 특정 문자 위치 저장

  ```c
  char array[ ]="ABCD";	// 문자열 변수 (변경 O)
  char* p="ABCD"; == char* p=&"ABCD"; // 문자열 상수 (변경 X)

  char* pa="Hello";
  char* pb="Hello"; // pa와 pb 주소 같은 값

  p[0]='X'; // 변경 불가능
  array[0]='X'; // 변경 가능

  p=array; // 변경 가능
  array=array+1; // 변경 불가능 (상수이므로 값이 고정되어 있음)
  ```

  - 포인터 연산 통해 문자열 전체 사용 가능
  - 컴파일러는 같은 문자열 상수 여러 번 사용할 경우 한 문자열만 메모리에 저장 (주소 공유)

- 널 포인터

  - 주소로 0 의미
  - 포인터 변수에 아무 주소도 저장하지 않겠다는 의미
  - 널 포인터를 사용할 때는 반드시 대문자를 사용
    ex) `int* p=NULL;`

- 포인터 변수의 상수화: const 키워드 이용
  - 포인터 변수에 다른 주소를 저장하지 못하게 함
    ex) **`char* const p=&a;`** → `*p='C';` (가능) / `p=&b;` (불가능)
  - 포인터 변수를 통해 메모리 공간의 값을 변경하지 못하게 함
    ex) **`const char p=&a;`** → `p=&b;`(가능) /`\*p='D';` (불가능)
  - 둘 다 못하게 함
    ex) **`const char* const p=&a;`** → `p=&b;`, `*p='D';` (불가능)

## 2. 문자열 입력 함수

- `scanf` 함수: `%s` 사용하여 공백 없는 연속된 문자열 입력

  - 키보드로 입력한 문자열 엔터 칠 때 버퍼에 저장
  - 버퍼에서 문자열 가져와 배열에 저장 후 종료문자 붙임 (공백문자 이전까지)
  - 문자열 저장할 때 배열 크기 알지 못함 (배열 시작 위치만 앎)
    → 배열 크기보다 큰 문자열 입력 시 오류 (종료문자까지 고려)
  - 화이트 스페이스 입력 시 계속 입력 기다림 (구분 용도 O, 실제 데이터로 입력 X)

- `gets` 함수: 중간 공백, 탭문자 포함해 문자열 한 줄 입력 ex) `gets(str);`

  - 키보드로 엔터 키 칠 때까지 입력한 한 줄을 char 배열에 저장
    → 개행 문자를 종료문자로 바꿔서 저장 (`\n` → `\0`)
  - 키보드로 입력한 데이터는 일단 버퍼에 저장된 후에 `gets` 함수가 가져옴
    → 문장이나 문단 가져올 수 있음 (공백, 탭문자 포함)
  - 엔터키만 쳐도 입력 종료

- `fgets` 함수: 배열 크기 확인해 최대 배열 크기까지 입력 받음
  ex) `fgets(str, sizeof(str), stdin);` → 문자열 저장 배열명, 배열 크기, 표준입력버퍼 입력
  - 배열 크기 넘는 문자열 입력해도 배열 크기만큼만 저장
  - 마지막에 종료문자 저장 → 배열 크기 -1개 문자만 저장
  - 개행문자도 배열에 저장한 후 종료문자 붙여서 저장 (`\n` → `\n\0`)
    ex) `str[strlen(str)-1]='\0';` → 개행문자 제거

## 3. 문자열 출력 함수

- `puts` 함수, `fputs` 함수: 화면에 문자열 출력 ex) `puts(str);`, `fputs(str, stdout);`
  - 정상 출력 시 0, 실패 시 -1 반환
  - 문자열 시작 위치부터 종료문자 나올 때까지 출력
  - 문자열 시작 주소 → char 배열의 배열명, 문자열 상수 저장한 포인터, 문자열 상수 사용 가능
  - `puts` 함수: 자동으로 줄 바꿈, `fputs` 함수: 줄 바꿈 하지 않음

## 4. 문자열 연산 함수

- `strcpy(str1, str2)`: 문자열 `str2`를 `str1`에 복사

  - 문자를 하나씩 대입하고 마지막에 종료문자 저장
  - `str1`는 char 배열과 char 배열 포인터만 가능 (문자열 상수는 값을 바꿀 수 없어서 오류)
  - `str2`는 다양한 값 사용 가능
  - `str2`의 크기는 종료문자 포함해서 `str1`의 크기 넘지 않아야 함

  > `strcpy(str1, str2, n)`: 문자열 `str2`를 `str1`에 문자 n개만 복사

- `strlen(str)`: 문자열 `str`의 길이(문자 수)를 구해 반환 → 종료 문자 제외

  - 배열 크기와 상관없이 저장된 문자열 길이 저장

- `strcat(str1, str2)`: 문자열 `str2`를 `str1` 문자열 뒤에 이어 붙임

  - `str2` 널문자의 위치부터 `str1` 복사 (반드시 초기화 먼저 해야 함)
  - 문자열 이어 붙인 후 종료문자 저장
  - `str1`의 배열 크기가 충분히 커야 함

  > `strcat(str1, str2, n)`: 문자열 `str2`를 `str1` 문자열 뒤에 문자 n개만 이어 붙임

- `strcmp(str1, str2)`: 문자열 `str1`이 `str2`보다 크면 1, 작으면 -1, 같은 문자열이면 0 반환
  - 두 문자열의 사전 순서 판단 (사전에 단어 수록되는 알파벳 순서)
  - 대소문자 일치시켜야 함 (대문자 아스키 코드값이 소문자보다 작아서 사전순서와 달라짐)
  - 숫자, 특수문자, 한글은 예외처리 해줘야함
    > `strcmp(str1, str2, n)`: 앞에서 n개의 문자만 비교
